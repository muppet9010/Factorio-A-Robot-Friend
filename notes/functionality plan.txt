Player Experience
-----------------

A job is what a player asks the robot to do. This will be top level wrapper around a given task and may give the player behaviour choices on how it is completed.

A task manages the doing of things by the robots. These can include direct actions by the robot in the map or managing child tasks.

When a robot is undertaking a task it will use multiple actions and sub tasks autonomously to complete the task. Tasks can take time and may include searches of the map in a time distributed fashion.

Actions are things where the robot interacts directly with the world. They are done instantly and thus managed by a task as everything needs to have a duration to complete. The master's name will be used as the player for all actions (ensures events are raised and so the correct player can be blamed).

Actions are:
    - Walking - LuaControl.walking_state
    - Driving - LuaControl.riding_state
    - Riding a train - give train a path and set off
    - Crafting - LuaControl.begin_crafting
    - Building - LuaSurface.create_entity (building from cursor is a LuaPlayer function)
    - Mining - LuaControl.mine_entity (have to wait the mining time as this will appear instant)
    - Upgrading - LuaSurface.create_entity (with fast_replace true)
    - Move items between chest and robot - LuaInventory.insert and LuaInventory.remove
    - Shooting - LuaControl.shooting_state (can target a position and then shoot nearest enemies or shoot at the ground)
    - Repairing - LuaControl.repair_state
    - Rotate entity - LuaEntity.rotate

Behaviours are related to the job and may dictate the action chosen or the choices made during the tasks decision process.

Tasks can contain other tasks. I.e. "build this blueprint" includes the tasks of obtaining a list of required materials, collecting or crafting them, moving there and placing the entities.

Tasks can be interrupted and will need to have a persisted state. When resumed the task will need to re-validate itself and confirm its current progress in the task is still accurate. Possibly returning to previously completed sub tasks and repeating their investigations and checking steps.

Planned Lower Tasks list (never directly called, but used by many other tasks in combinations):
    - Walk a path
    - Find walking path
    - Search chests for items
    - Scan area for ghosted items
    - Craft required item from ingredients in robot inventory

Planned Medium Tasks list (actually callable on their own in simple situations):
    - Walk to location:
        - Find walking path
        - Walk a path
    - Collect items:
        - Search chests for items. Looking for as many items as we can until our inventory fills up. In the hope that anything we can;t get now and our inventory is full may be available when we return.
        - Collect item from chest (loops):
            - Move to location
            - Move items between chest and robot
            - Review if other needed items are in chests and either loop or move on to next step.
        - Craft required items not in chests (loop):
            - Identify ingredients needed for required item type
            - For each ingredient:
                - Identify if robot has these items already
                - Search chests for items and record if they exist.
            - If all ingredients for recipe can be obtained then collect them from the chests:
                - Move to location
                - Move items between chest and robot
                - Review if other needed items are in chests and either loop or move on to next step.
            - Otherwise flag item as not obtainable.
            - Craft items that are possible.
        - Report to master any items that can not be obtained. Let master decide if robot considers task as completed and continues with job or waits for master to resolve issue and then repeats the collection activities.
    - Complete ghosts (includes build, mining, upgrading, rotating, etc):
        - Scan area for ghosted items (if not passed in)
        - For each ghost item:
            - Do we have material to do it, if not skip it for now and mark it for later.
            - Do we need to move to reach it, if so:
                - Move to location
            - Do action (build, mining, upgrading, rotating, etc)
            - Loop back until finished.

Planned Jobs Tasks list (main tasks that masters will generally get their robots to do):
    - Complete Blueprint:
        - Scan area for ghosted items
        - Collect items
        - Move to location
        - Complete ghosts
        - Repeat scan area and either re-loop or job completed.
    - Move to location:
        - After finding distance:
            - Walk to location
            - Drive to location
            - Ride train to location

Jobs are owned and managed by a single player. A robot is owned by a single player. Players can assign their robots to their own jobs or to other player's jobs.

All jobs will have some standard options like travel type restrictions (i.e. block car usage), combat mode, etc. There should be per player settings/GUI to control defaults for these as well.

We won't support updating jobs, but will allow via the GUI some sort of clone (with/out robots) to allow quick copying/replacing of them.

Multiple robots can be assigned to the same job and based on the type of task being done the robots will either work together or independently.



Internal Code Structure
-----------------------

Tasks should register their calling function by name in to MOD.Interfaces.Tasks and MOD.Interfaces.Jobs. Then the Jobs/Tasks can store the name in their global data to be save/load safe. The interfaces can be used to call from one task to another up/down the chain in a save/load safe manner.

Jobs and tasks both act largely as black boxes to the other layers (robots, GUI). Types of jobs and tasks implement standard core interface for data and functions, with additional bespoke extras per type. This allows for calling between the layers to normally be generic, with only specific types of tasks and jobs calling to other specific tasks and their bespoke functions and data.

Each layer should call only to other managers, with each manager then knowing its own areas structure and calling in to the specific modules. Also means that Sumneko type identification works better as managers functions are all clearly defined, with any greyness from Factory type interfaces within their functions.
Exceptions are when a specific job needs to call to a specific task, as it needs to know the specific tasks arguments.

Avoid pre-emptive UPS optimisation as most things are run once per tick per robot at most. And so this load will be very evenly distributed and low background. Aim for minimal optimisation especially on state data to keep code simpler to maintain.

There is only 1 task hierarchy per job regardless of the number of robots. Tasks will either implement independent robot activities or some form of coordinated planning and action across all robots actively working on that task. As there's only 1 instance of a task per job this means the task can act as a black box regarding how it handles robots from other tasks. It also allows for clean data sharing at any point in the task hierarchy. When multiple robots are on a job and some finish their part of a common task and others are still working, it will be up to the task to define if the robots should get released to the next task (task still active as a whole), or if the robots should have their activity within the task reset to include new work.
Previously per robot task instance was trialled, but found to be problematic in a design/structural sense for data sharing at depths in the task hierarchy between robots.

Job:
    PrimaryTask Task Data for Job:
        Per Robot Task Data list
        Job task data
        Child Task Data:
            (
            Per Robot Task Data list
            Job task data
            Child Task Data:
            ) to N level

Robot:
    Active Jobs list referencing the Job.

Robot do work function calls: Robot > Job > Primary Task For Job > Task calls in to child task with mix of per robot and job's task data as appropriate > Task cascades down hierarchy as required.