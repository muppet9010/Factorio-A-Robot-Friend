A job is what a player asks the robot to do. This will be top level wrapper around a given task and may give the player behaviour choices on how it is completed.

When a robot is undertaking a task it will use multiple actions and sub tasks autonomously to complete the task. Tasks can take time and may include searches of the map in a time distributed fashion.

Actions are things where the robot interacts directly with the world. They are done instantly and thus managed by a task as everything needs to have a duration to complete. The master's name will be used as the player for all actions (ensures events are raised and so the correct player can be blamed).

Actions are:
    - Walking - LuaControl.walking_state
    - Driving - LuaControl.riding_state
    - Riding a train - give train a path and set off
    - Crafting - LuaControl.begin_crafting
    - Building - LuaSurface.create_entity (building from cursor is a LuaPlayer function)
    - Mining - LuaControl.mine_entity (have to wait the mining time as this will appear instant)
    - Upgrading - LuaSurface.create_entity (with fast_replace true)
    - Move items between chest and robot - LuaInventory.insert and LuaInventory.remove
    - Shooting - LuaControl.shooting_state (can target a position and then shoot nearest enemies or shoot at the ground)
    - Repairing - LuaControl.repair_state
    - Rotate entity - LuaEntity.rotate

Behaviours are related to the job and may dictate the action chosen or the choices made during the tasks decision process.

Tasks can contain other tasks. I.e. "build this blueprint" includes the tasks of obtaining a list of required materials, collecting or crafting them, moving there and placing the entities.

Tasks can be interrupted and will need to have a persisted state. When resumed the task will need to re-validate itself and confirm its current progress in the task is still accurate. Possibly returning to previously completed sub tasks and repeating their investigations and checking steps.

Tasks should register their calling function by name in to MOD.Interfaces.Tasks and MOD.Interfaces.Jobs. Then the Jobs/Tasks can store the name in their global data to be save/load safe. The interfaces can be used to call from one task to another up/down the chain in a save/load safe manner.

Planned Lower Tasks list (never directly called, but used by many other tasks in combinations):
    - Walk a path
    - Find walking path
    - Search chests for items
    - Scan area for ghosted items
    - Craft required item from ingredients in robot inventory

Planned Medium Tasks list (actually callable on their own in simple situations):
    - Walk to location:
        - Find walking path
        - Walk a path
    - Collect items:
        - Search chests for items. Looking for as many items as we can until our inventory fills up. In the hope that anything we can;t get now and our inventory is full may be available when we return.
        - Collect item from chest (loops):
            - Move to location
            - Move items between chest and robot
            - Review if other needed items are in chests and either loop or move on to next step.
        - Craft required items not in chests (loop):
            - Identify ingredients needed for required item type
            - For each ingredient:
                - Identify if robot has these items already
                - Search chests for items and record if they exist.
            - If all ingredients for recipe can be obtained then collect them from the chests:
                - Move to location
                - Move items between chest and robot
                - Review if other needed items are in chests and either loop or move on to next step.
            - Otherwise flag item as not obtainable.
            - Craft items that are possible.
        - Report to master any items that can not be obtained. Let master decide if robot considers task as completed and continues with job or waits for master to resolve issue and then repeats the collection activities.
    - Complete ghosts (includes build, mining, upgrading, rotating, etc):
        - Scan area for ghosted items (if not passed in)
        - For each ghost item:
            - Do we have material to do it, if not skip it for now and mark it for later.
            - Do we need to move to reach it, if so:
                - Move to location
            - Do action (build, mining, upgrading, rotating, etc)
            - Loop back until finished.



Planned Jobs Tasks list (main tasks that masters will generally get their robots to do):
    - Complete Blueprint:
        - Scan area for ghosted items
        - Collect items
        - Move to location
        - Complete ghosts
        - Repeat scan area and either re-loop or job completed.
    - Move to location:
        - After finding distance:
            - Walk to location
            - Drive to location
            - Ride train to location


Jobs are owned and managed by a single player. A robot is owned by a single player. Players can assign their robots to their own jobs or to other player's jobs.

All jobs will have some standard options like travel type restrictions (i.e. block car usage), combat mode, etc. There should be per player settings/GUI to control defaults for these as well.

We won't support updating jobs, but will allow via the GUI some sort of clone (with/out robots) to allow quick copying/replacing of them.

Multiple robots can be assigned to the same job. Each robot will have its own main primaryTask and task hierarchy under the Job. As this way the a task can cross talk and share data when needed between each robots version. In most cases the tasks will be entirely separate as the robots will be doing their own thing within their own section of the task.
When multiple robots are on a job and some finish all their tasks and others are still working, it will be up to the tasks to define if the robots should get new sub tasks to help, or if their role is completed and they should move on to their next job (some robots still working, others will consider themselves finished and move on).

Each layer should call only to other managers, with each manager then knowing its own areas structure and calling in to the specific modules. Also means that Sumneko type identification works better as managers functions are all clearly defined, with any greyness from Factory type interfaces within their functions.
Exceptions are when a specific job needs to call to a specific task, as it needs to know the specific tasks arguments.

Avoid pre-emptive UPS optimisation as most things are run once per tick per robot at most. And so this load will be very evenly distributed and low background. Aim for minimal optimisation especially on state data to keep code simpler to maintain.



Current - Task hierarchy per robot
-------

Job:
    Robots to their instance of Primary Task Data list:
        This robots task data
        Child Task Data:
            (
            This robots task data
            Child Task Data:
            ) to N level

Robot:
    Active Jobs list referencing the Job.

Robot do work function calls: Robot > Job > Primary Task for Robot > Child Task (N)




Future - Task hierarchy per job with task specific per robot task data.
------

Job:
    PrimaryTask Task Data for Job:
        Per Robot Task Data list
        Job task data
        Child Task Data:
            (
            Per Robot Task Data list
            Job task data
            Child Task Data:
            ) to N level

Robot:
    Active Jobs list referencing the Job.

Robot do work function calls: Robot > Job > Primary Task For Job > Task calls in to child task with mix of per robot and job's task data.